package net.oneria.oneriaserverutilities;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.BoolArgumentType;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.exceptions.CommandSyntaxException;
import com.mojang.brigadier.suggestion.SuggestionProvider;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;
import net.minecraft.commands.arguments.EntityArgument;
import net.minecraft.commands.arguments.ResourceLocationArgument;
import net.minecraft.core.Holder;
import net.minecraft.core.registries.BuiltInRegistries;
import net.minecraft.network.chat.Component;
import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
import net.minecraft.resources.ResourceKey;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.effect.MobEffect;
import net.minecraft.world.effect.MobEffectInstance;
import net.minecraft.world.level.GameType;
import net.minecraft.world.level.Level;
import net.minecraft.world.phys.Vec3;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.RegisterCommandsEvent;
import net.neoforged.neoforge.network.PacketDistributor;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Optional;

@EventBusSubscriber(modid = OneriaServerUtilities.MODID)
public class OneriaCommands {

    private static final SuggestionProvider<CommandSourceStack> PLATFORM_SUGGESTIONS = (ctx, builder) -> {
        try {
            if (OneriaConfig.PLATFORMS != null && OneriaConfig.PLATFORMS.get() != null) {
                for (String platform : OneriaConfig.PLATFORMS.get()) {
                    String[] parts = platform.split(";");
                    if (parts.length > 0) {
                        builder.suggest(parts[0]);
                    }
                }
            }
        } catch (IllegalStateException e) {
        }
        return builder.buildFuture();
    };

    @SubscribeEvent
    public static void onRegisterCommands(RegisterCommandsEvent event) {
        CommandDispatcher<CommandSourceStack> dispatcher = event.getDispatcher();

        // =========================================================================
        // MAIN COMMAND: /oneria
        // =========================================================================
        var oneriaRoot = Commands.literal("oneria");

        // -------------------------------------------------------------------------
        // 1. MODULE: CONFIGURATION (Requires OP Level 2)
        // -------------------------------------------------------------------------
        var configNode = Commands.literal("config")
                .requires(source -> source.hasPermission(2));

        // Reload
        configNode.then(Commands.literal("reload")
                .executes(OneriaCommands::reloadConfig));

        // Status
        configNode.then(Commands.literal("status")
                .executes(OneriaCommands::showStatus));

        // Setters (On-the-fly modifications)
        var setNode = Commands.literal("set");

        // Obfuscation settings
        setNode.then(Commands.literal("proximity")
                .then(Commands.argument("value", IntegerArgumentType.integer(1, 128))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.PROXIMITY_DISTANCE, "Proximity distance"))));

        setNode.then(Commands.literal("blur")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_BLUR, "Blur"))));

        setNode.then(Commands.literal("obfuscatedNameLength")
                .then(Commands.argument("value", IntegerArgumentType.integer(1, 16))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.OBFUSCATED_NAME_LENGTH, "Hidden name length"))));

        setNode.then(Commands.literal("obfuscatePrefix")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.OBFUSCATE_PREFIX, "Obfuscate prefix"))));

        setNode.then(Commands.literal("opsSeeAll")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.OPS_SEE_ALL, "Admin View"))));

        setNode.then(Commands.literal("debugSelfBlur")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.DEBUG_SELF_BLUR, "Debug Self Blur"))));

        // Schedule settings
        setNode.then(Commands.literal("enableSchedule")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_SCHEDULE, "Schedule System"))));

        setNode.then(Commands.literal("openingTime")
                .then(Commands.argument("time", StringArgumentType.word())
                        .executes(OneriaCommands::setOpeningTime)));

        setNode.then(Commands.literal("closingTime")
                .then(Commands.argument("time", StringArgumentType.word())
                        .executes(OneriaCommands::setClosingTime)));

        setNode.then(Commands.literal("kickNonStaff")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.KICK_NON_STAFF, "Kick Non-Staff"))));

        // Welcome settings
        setNode.then(Commands.literal("enableWelcome")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_WELCOME, "Welcome Message"))));

        // Platform settings
        setNode.then(Commands.literal("enablePlatforms")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_PLATFORMS, "Platforms System"))));

        // Silent commands settings
        setNode.then(Commands.literal("enableSilentCommands")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_SILENT_COMMANDS, "Silent Commands"))));

        setNode.then(Commands.literal("logToStaff")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.LOG_TO_STAFF, "Log to Staff"))));

        setNode.then(Commands.literal("logToConsole")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.LOG_TO_CONSOLE, "Log to Console"))));

        setNode.then(Commands.literal("notifyTarget")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.NOTIFY_TARGET, "Notify Target"))));

        // Permission settings
        setNode.then(Commands.literal("opLevelBypass")
                .then(Commands.argument("value", IntegerArgumentType.integer(0, 4))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.OP_LEVEL_BYPASS, "OP Level Bypass"))));

        setNode.then(Commands.literal("useLuckPermsGroups")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.USE_LUCKPERMS_GROUPS, "Use LuckPerms Groups"))));

        // Chat settings
        setNode.then(Commands.literal("enableChatFormat")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_CHAT_FORMAT, "Chat Format"))));

        setNode.then(Commands.literal("enableTimestamp")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_TIMESTAMP, "Timestamp"))));

        setNode.then(Commands.literal("markdownEnabled")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.MARKDOWN_ENABLED, "Markdown"))));

        setNode.then(Commands.literal("chatMessageColor")
                .then(Commands.argument("color", StringArgumentType.word())
                        .suggests((ctx, builder) -> {
                            builder.suggest("AQUA").suggest("RED").suggest("LIGHT_PURPLE")
                                    .suggest("YELLOW").suggest("WHITE").suggest("BLACK")
                                    .suggest("GOLD").suggest("GRAY").suggest("BLUE")
                                    .suggest("GREEN").suggest("DARK_GRAY").suggest("DARK_AQUA")
                                    .suggest("DARK_RED").suggest("DARK_PURPLE")
                                    .suggest("DARK_GREEN").suggest("DARK_BLUE");
                            return builder.buildFuture();
                        })
                        .executes(ctx -> {
                            String color = StringArgumentType.getString(ctx, "color");
                            OneriaConfig.CHAT_MESSAGE_COLOR.set(color);
                            OneriaConfig.SPEC.save();
                            ctx.getSource().sendSuccess(() ->
                                            Component.literal("§a[Oneria] Chat Message Color set to: " + color),
                                    true
                            );
                            return 1;
                        })));

        setNode.then(Commands.literal("timestampFormat")
                .then(Commands.argument("format", StringArgumentType.greedyString())
                        .executes(ctx -> {
                            String format = StringArgumentType.getString(ctx, "format");
                            OneriaConfig.TIMESTAMP_FORMAT.set(format);
                            OneriaConfig.SPEC.save();
                            ctx.getSource().sendSuccess(() ->
                                            Component.literal("§a[Oneria] Timestamp Format set to: " + format),
                                    true
                            );
                            return 1;
                        })));

        setNode.then(Commands.literal("enableColorsCommand")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_COLORS_COMMAND, "Colors Command"))));

        setNode.then(Commands.literal("enableSneakStealth")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_SNEAK_STEALTH, "Sneak Stealth Mode"))));

        setNode.then(Commands.literal("sneakProximityDistance")
                .then(Commands.argument("value", IntegerArgumentType.integer(1, 32))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.SNEAK_PROXIMITY_DISTANCE, "Sneak Detection Distance"))));

        setNode.then(Commands.literal("hideNametags")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.HIDE_NAMETAGS, "Hide Nametags"))));

        setNode.then(Commands.literal("showNametagPrefixSuffix")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.SHOW_NAMETAG_PREFIX_SUFFIX, "Show Nametag Prefix/Suffix"))));

// Join/Leave messages settings
        setNode.then(Commands.literal("enableCustomJoinLeave")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_CUSTOM_JOIN_LEAVE, "Custom Join/Leave Messages"))));

        setNode.then(Commands.literal("joinMessage")
                .then(Commands.argument("message", StringArgumentType.greedyString())
                        .executes(ctx -> {
                            String msg = StringArgumentType.getString(ctx, "message");
                            OneriaConfig.JOIN_MESSAGE.set(msg);
                            OneriaConfig.SPEC.save();
                            ctx.getSource().sendSuccess(() ->
                                            Component.literal("§a[Oneria] Join Message set to: " + msg),
                                    true
                            );
                            return 1;
                        })));

        setNode.then(Commands.literal("leaveMessage")
                .then(Commands.argument("message", StringArgumentType.greedyString())
                        .executes(ctx -> {
                            String msg = StringArgumentType.getString(ctx, "message");
                            OneriaConfig.LEAVE_MESSAGE.set(msg);
                            OneriaConfig.SPEC.save();
                            ctx.getSource().sendSuccess(() ->
                                            Component.literal("§a[Oneria] Leave Message set to: " + msg),
                                    true
                            );
                            return 1;
                        })));

        // World Border settings
        setNode.then(Commands.literal("enableWorldBorderWarning")
                .then(Commands.argument("value", BoolArgumentType.bool())
                        .executes(ctx -> updateConfigBool(ctx, OneriaConfig.ENABLE_WORLD_BORDER_WARNING, "World Border Warning"))));

        setNode.then(Commands.literal("worldBorderDistance")
                .then(Commands.argument("value", IntegerArgumentType.integer(100, 100000))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.WORLD_BORDER_DISTANCE, "World Border Distance"))));

        setNode.then(Commands.literal("worldBorderMessage")
                .then(Commands.argument("message", StringArgumentType.greedyString())
                        .executes(ctx -> {
                            String msg = StringArgumentType.getString(ctx, "message");
                            OneriaConfig.WORLD_BORDER_MESSAGE.set(msg);
                            OneriaConfig.SPEC.save();
                            ctx.getSource().sendSuccess(() ->
                                            Component.literal("§a[Oneria] World Border Message set to: " + msg),
                                    true
                            );
                            return 1;
                        })));

        setNode.then(Commands.literal("worldBorderCheckInterval")
                .then(Commands.argument("value", IntegerArgumentType.integer(20, 200))
                        .executes(ctx -> updateConfigInt(ctx, OneriaConfig.WORLD_BORDER_CHECK_INTERVAL, "World Border Check Interval"))));

        configNode.then(setNode);
        oneriaRoot.then(configNode);

        // -------------------------------------------------------------------------
        // 2. MODULE: STAFF & MODERATION (Requires 'isStaff' permission)
        // -------------------------------------------------------------------------
        var staffNode = Commands.literal("staff")
                .requires(src -> OneriaPermissions.isStaff(src.getPlayer()));

        // Silent Gamemode
        staffNode.then(Commands.literal("gamemode")
                .then(Commands.argument("mode", StringArgumentType.word())
                        .suggests((ctx, builder) -> {
                            builder.suggest("survival").suggest("creative").suggest("adventure").suggest("spectator");
                            return builder.buildFuture();
                        })
                        .executes(OneriaCommands::silentGamemodeSelf)
                        .then(Commands.argument("target", EntityArgument.player())
                                .executes(OneriaCommands::silentGamemodeTarget)
                        )
                )
        );

        // Silent Teleport
        staffNode.then(Commands.literal("tp")
                .then(Commands.argument("target", EntityArgument.player())
                        .executes(OneriaCommands::silentTeleport)
                )
        );

        // Silent Effects
        staffNode.then(Commands.literal("effect")
                .then(Commands.argument("target", EntityArgument.player())
                        .then(Commands.argument("effect", ResourceLocationArgument.id())
                                .suggests((ctx, builder) -> {
                                    BuiltInRegistries.MOB_EFFECT.keySet().forEach(loc -> builder.suggest(loc.toString()));
                                    return builder.buildFuture();
                                })
                                .then(Commands.argument("duration", IntegerArgumentType.integer(1))
                                        .then(Commands.argument("amplifier", IntegerArgumentType.integer(0))
                                                .executes(OneriaCommands::silentEffect)
                                        )
                                )
                        )
                )
        );

        // Platforms (CORRECTION ICI : utilisation du SuggestionProvider)
        staffNode.then(Commands.literal("platform")
                .executes(OneriaCommands::platformSelf)
                .then(Commands.argument("target", EntityArgument.player())
                        .executes(OneriaCommands::platformTarget)
                        .then(Commands.argument("platform_id", StringArgumentType.word())
                                .suggests(PLATFORM_SUGGESTIONS)  // ← FIX : Plus de crash !
                                .executes(OneriaCommands::platformTargetSpecific)
                        )
                )
        );

        // Alias /setplatform pour les admins
        dispatcher.register(Commands.literal("setplatform")
                .requires(source -> source.hasPermission(2))
                .then(Commands.argument("platform_name", StringArgumentType.word())
                        .then(Commands.argument("dimension", ResourceLocationArgument.id())
                                .then(Commands.argument("x", IntegerArgumentType.integer())
                                        .then(Commands.argument("y", IntegerArgumentType.integer())
                                                .then(Commands.argument("z", IntegerArgumentType.integer())
                                                        .executes(OneriaCommands::setPlatform)
                                                )
                                        )
                                )
                        )
                ));

        oneriaRoot.then(staffNode);

        // -------------------------------------------------------------------------
        // 3. MODULE: WHITELIST (Requires OP Level 2)
        // -------------------------------------------------------------------------
        var whitelistNode = Commands.literal("whitelist")
                .requires(source -> source.hasPermission(2));

        whitelistNode.then(Commands.literal("add")
                .then(Commands.argument("player", StringArgumentType.string())
                        .executes(OneriaCommands::addToWhitelist)));

        whitelistNode.then(Commands.literal("remove")
                .then(Commands.argument("player", StringArgumentType.string())
                        .executes(OneriaCommands::removeFromWhitelist)));

        whitelistNode.then(Commands.literal("list")
                .executes(OneriaCommands::listWhitelist));

        oneriaRoot.then(whitelistNode);

        // -------------------------------------------------------------------------
        // 4. MODULE: BLACKLIST (Requires OP Level 2)
        // -------------------------------------------------------------------------
        var blacklistNode = Commands.literal("blacklist")
                .requires(source -> source.hasPermission(2));

        blacklistNode.then(Commands.literal("add")
                .then(Commands.argument("player", StringArgumentType.string())
                        .executes(OneriaCommands::addToBlacklist)));

        blacklistNode.then(Commands.literal("remove")
                .then(Commands.argument("player", StringArgumentType.string())
                        .executes(OneriaCommands::removeFromBlacklist)));

        blacklistNode.then(Commands.literal("list")
                .executes(OneriaCommands::listBlacklist));

        oneriaRoot.then(blacklistNode);

        // -------------------------------------------------------------------------
        // 5. MODULE: NICKNAME (Requires OP Level 2)
        // -------------------------------------------------------------------------
        var nickNode = Commands.literal("nick")
                .requires(source -> source.hasPermission(2));

        nickNode.then(Commands.argument("player", EntityArgument.player())
                .then(Commands.argument("nickname", StringArgumentType.greedyString())
                        .executes(OneriaCommands::setNickname)
                )
                .executes(OneriaCommands::resetNickname)
        );

        nickNode.then(Commands.literal("list")
                .executes(OneriaCommands::listNicknames)
        );

        oneriaRoot.then(nickNode);

        // -------------------------------------------------------------------------
        // 6. MODULE: SCHEDULE (Public)
        // -------------------------------------------------------------------------
        oneriaRoot.then(Commands.literal("schedule")
                .executes(OneriaCommands::showSchedule));

        // Register root
        dispatcher.register(oneriaRoot);

        // =========================================================================
        // COLORS COMMAND - CORRECTION
        // =========================================================================
        dispatcher.register(Commands.literal("colors")
                .executes(ctx -> {
                    if (OneriaConfig.ENABLE_COLORS_COMMAND != null &&
                            !OneriaConfig.ENABLE_COLORS_COMMAND.get()) {
                        ctx.getSource().sendFailure(Component.literal("§cColors command is disabled."));
                        return 0;
                    }
                    return OneriaCommands.showColors(ctx);
                }));

        // =========================================================================
        // HANDY ALIASES
        // =========================================================================
        dispatcher.register(Commands.literal("schedule")
                .executes(OneriaCommands::showSchedule));

        dispatcher.register(Commands.literal("horaires")
                .executes(OneriaCommands::showSchedule));

        dispatcher.register(Commands.literal("platform")
                .requires(src -> OneriaPermissions.isStaff(src.getPlayer()))
                .executes(OneriaCommands::platformSelf)
                .then(Commands.argument("target", EntityArgument.player())
                        .executes(OneriaCommands::platformTarget)
                        .then(Commands.argument("platform_id", StringArgumentType.word())
                                .suggests(PLATFORM_SUGGESTIONS)  // ← FIX : Plus de crash !
                                .executes(OneriaCommands::platformTargetSpecific)
                        )
                ));
    }

    // =============================================================================
    // IMPLEMENTATION LOGIC (HANDLERS)
    // =============================================================================

    // --- CONFIG HANDLERS ---

    private static int reloadConfig(CommandContext<CommandSourceStack> ctx) {
        OneriaScheduleManager.reload();
        OneriaPermissions.clearCache();
        NicknameManager.reload();

        ctx.getSource().sendSuccess(() -> Component.literal("§a[Oneria] Configuration, nicknames and nametags reloaded!"), true);
        return 1;
    }

    private static int updateConfigInt(CommandContext<CommandSourceStack> ctx, net.neoforged.neoforge.common.ModConfigSpec.IntValue config, String name) {
        int val = IntegerArgumentType.getInteger(ctx, "value");
        config.set(val);
        OneriaConfig.SPEC.save();
        ctx.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + name + " set to: " + val), true);
        return 1;
    }

    private static int updateConfigBool(CommandContext<CommandSourceStack> ctx, net.neoforged.neoforge.common.ModConfigSpec.BooleanValue config, String name) {
        boolean val = BoolArgumentType.getBool(ctx, "value");
        config.set(val);
        OneriaConfig.SPEC.save();

        if (config == OneriaConfig.HIDE_NAMETAGS) {
            ctx.getSource().getServer().getPlayerList().getPlayers().forEach(player -> {
                PacketDistributor.sendToPlayer(player, new HideNametagsPacket(val));
            });
            OneriaServerUtilities.LOGGER.info("Broadcast nametag config update: hide={}", val);
        }

        ctx.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + name + " : " + (val ? "§aENABLED" : "§cDISABLED")), true);
        return 1;
    }

    private static int setOpeningTime(CommandContext<CommandSourceStack> ctx) {
        String time = StringArgumentType.getString(ctx, "time");
        if (!time.matches("\\d{2}:\\d{2}")) {
            ctx.getSource().sendFailure(Component.literal("§cInvalid format! Use HH:MM (e.g., 19:00)"));
            return 0;
        }
        OneriaConfig.OPENING_TIME.set(time);
        OneriaConfig.SPEC.save();
        OneriaScheduleManager.reload();
        ctx.getSource().sendSuccess(() -> Component.literal("§a[Oneria] Opening time set to: " + time), true);
        return 1;
    }

    private static int setClosingTime(CommandContext<CommandSourceStack> ctx) {
        String time = StringArgumentType.getString(ctx, "time");
        if (!time.matches("\\d{2}:\\d{2}")) {
            ctx.getSource().sendFailure(Component.literal("§cInvalid format! Use HH:MM (e.g., 23:59)"));
            return 0;
        }
        OneriaConfig.CLOSING_TIME.set(time);
        OneriaConfig.SPEC.save();
        OneriaScheduleManager.reload();
        ctx.getSource().sendSuccess(() -> Component.literal("§a[Oneria] Closing time set to: " + time), true);
        return 1;
    }

    private static int showStatus(CommandContext<CommandSourceStack> context) {
        try {
            final java.util.function.Function<java.util.function.Supplier<?>, String> safe = (supplier) -> {
                try {
                    Object val = supplier.get();
                    return val != null ? val.toString() : "N/A";
                } catch (Exception e) {
                    return "N/A";
                }
            };

            // Helper pour le status du schedule
            String scheduleStatus;
            try {
                scheduleStatus = OneriaScheduleManager.isServerOpen() ? "§aOPEN" : "§cCLOSED";
            } catch (Exception e) {
                scheduleStatus = "§7N/A";
            }

            String statusMessage =
                    "§6╔═══════════════════════════════════╗\n" +
                            "§6║  §e§lONERIA MOD - STATUS§r          §6║\n" +
                            "§6╠═══════════════════════════════════╣\n" +
                            "§6║ §7Obfuscation\n" +
                            "§6║  §eBlur: §f" + safe.apply(() -> OneriaConfig.ENABLE_BLUR.get()) + "\n" +
                            "§6║  §eProximity: §f" + safe.apply(() -> OneriaConfig.PROXIMITY_DISTANCE.get()) + " blocks\n" +
                            "§6║  §eObfuscate Prefix: §f" + safe.apply(() -> OneriaConfig.OBFUSCATE_PREFIX.get()) + "\n" +
                            "§6║  §eOPs See All: §f" + safe.apply(() -> OneriaConfig.OPS_SEE_ALL.get()) + "\n" +
                            "§6║  §eHide Nametags: §f" + safe.apply(() -> OneriaConfig.HIDE_NAMETAGS.get()) + "\n" +
                            "§6║  §eSneak Stealth: §f" + safe.apply(() -> OneriaConfig.ENABLE_SNEAK_STEALTH.get()) + "\n" +
                            "§6║  §eSneak Distance: §f" + safe.apply(() -> OneriaConfig.SNEAK_PROXIMITY_DISTANCE.get()) + " blocks\n" +
                            "§6║\n" +
                            "§6║ §7Schedule\n" +
                            "§6║  §eEnabled: §f" + safe.apply(() -> OneriaConfig.ENABLE_SCHEDULE.get()) + "\n" +
                            "§6║  §eStatus: " + scheduleStatus + "\n" +
                            "§6║  §eOpening: §f" + safe.apply(() -> OneriaConfig.OPENING_TIME.get()) + "\n" +
                            "§6║  §eClosing: §f" + safe.apply(() -> OneriaConfig.CLOSING_TIME.get()) + "\n" +
                            "§6║\n" +
                            "§6║ §7Chat System\n" +
                            "§6║  §eChat Format: §f" + safe.apply(() -> OneriaConfig.ENABLE_CHAT_FORMAT.get()) + "\n" +
                            "§6║  §eTimestamp: §f" + safe.apply(() -> OneriaConfig.ENABLE_TIMESTAMP.get()) + "\n" +
                            "§6║  §eMarkdown: §f" + safe.apply(() -> OneriaConfig.MARKDOWN_ENABLED.get()) + "\n" +
                            "§6║  §eMessage Color: §f" + safe.apply(() -> OneriaConfig.CHAT_MESSAGE_COLOR.get()) + "\n" +
                            "§6║\n" +
                            "§6║ §7Join/Leave Messages\n" +
                            "§6║  §eEnabled: §f" + safe.apply(() -> OneriaConfig.ENABLE_CUSTOM_JOIN_LEAVE.get()) + "\n" +
                            "§6║\n" +
                            "§6║ §7World Border\n" +
                            "§6║  §eEnabled: §f" + safe.apply(() -> OneriaConfig.ENABLE_WORLD_BORDER_WARNING.get()) + "\n" +
                            "§6║  §eDistance: §f" + safe.apply(() -> OneriaConfig.WORLD_BORDER_DISTANCE.get()) + " blocks\n" +
                            "§6║\n" +
                            "§6║ §7Moderation\n" +
                            "§6║  §eSilent Commands: §f" + safe.apply(() -> OneriaConfig.ENABLE_SILENT_COMMANDS.get()) + "\n" +
                            "§6║  §ePlatforms: §f" + safe.apply(() -> OneriaConfig.ENABLE_PLATFORMS.get()) + "\n" +
                            "§6║  §eWelcome Message: §f" + safe.apply(() -> OneriaConfig.ENABLE_WELCOME.get()) + "\n" +
                            "§6╚═══════════════════════════════════╝";

            context.getSource().sendSuccess(() -> Component.literal(statusMessage), false);
            return 1;
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("§c[Oneria] Error displaying status: " + e.getMessage()));
            OneriaServerUtilities.LOGGER.error("Error in showStatus", e);
            return 0;
        }
    }

    // --- WHITELIST HANDLERS ---

    private static int addToWhitelist(CommandContext<CommandSourceStack> context) {
        String player = StringArgumentType.getString(context, "player");
        List<String> list = new ArrayList<>(OneriaConfig.WHITELIST.get());
        if (!list.contains(player)) {
            list.add(player);
            OneriaConfig.WHITELIST.set(list);
            OneriaConfig.SPEC.save();
            context.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + player + " added to whitelist."), true);
        } else {
            context.getSource().sendFailure(Component.literal("§c[Oneria] " + player + " is already in whitelist."));
        }
        return 1;
    }

    private static int removeFromWhitelist(CommandContext<CommandSourceStack> context) {
        String player = StringArgumentType.getString(context, "player");
        List<String> list = new ArrayList<>(OneriaConfig.WHITELIST.get());
        if (list.remove(player)) {
            OneriaConfig.WHITELIST.set(list);
            OneriaConfig.SPEC.save();
            context.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + player + " removed from whitelist."), true);
        } else {
            context.getSource().sendFailure(Component.literal("§c[Oneria] " + player + " is not in whitelist."));
        }
        return 1;
    }

    private static int listWhitelist(CommandContext<CommandSourceStack> context) {
        List<? extends String> whitelist = OneriaConfig.WHITELIST.get();
        if (whitelist.isEmpty()) {
            context.getSource().sendSuccess(() -> Component.literal("§e[Oneria] Whitelist is empty."), false);
        } else {
            context.getSource().sendSuccess(() -> Component.literal("§e[Oneria] Whitelist: §f" + String.join(", ", whitelist)), false);
        }
        return 1;
    }

    // --- BLACKLIST HANDLERS ---

    private static int addToBlacklist(CommandContext<CommandSourceStack> context) {
        String player = StringArgumentType.getString(context, "player");
        List<String> list = new ArrayList<>(OneriaConfig.BLACKLIST.get());
        if (!list.contains(player)) {
            list.add(player);
            OneriaConfig.BLACKLIST.set(list);
            OneriaConfig.SPEC.save();
            context.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + player + " added to blacklist (always hidden)."), true);
        } else {
            context.getSource().sendFailure(Component.literal("§c[Oneria] " + player + " is already in blacklist."));
        }
        return 1;
    }

    private static int removeFromBlacklist(CommandContext<CommandSourceStack> context) {
        String player = StringArgumentType.getString(context, "player");
        List<String> list = new ArrayList<>(OneriaConfig.BLACKLIST.get());
        if (list.remove(player)) {
            OneriaConfig.BLACKLIST.set(list);
            OneriaConfig.SPEC.save();
            context.getSource().sendSuccess(() -> Component.literal("§a[Oneria] " + player + " removed from blacklist."), true);
        } else {
            context.getSource().sendFailure(Component.literal("§c[Oneria] " + player + " is not in blacklist."));
        }
        return 1;
    }

    private static int listBlacklist(CommandContext<CommandSourceStack> context) {
        List<? extends String> blacklist = OneriaConfig.BLACKLIST.get();
        if (blacklist.isEmpty()) {
            context.getSource().sendSuccess(() -> Component.literal("§e[Oneria] Blacklist is empty."), false);
        } else {
            context.getSource().sendSuccess(() -> Component.literal("§e[Oneria] Blacklist (always hidden): §f" + String.join(", ", blacklist)), false);
        }
        return 1;
    }

    // --- STAFF HANDLERS (SILENT) ---

    private static int silentGamemodeSelf(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        return setGamemode(ctx, ctx.getSource().getPlayerOrException(), StringArgumentType.getString(ctx, "mode"));
    }

    private static int silentGamemodeTarget(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        return setGamemode(ctx, EntityArgument.getPlayer(ctx, "target"), StringArgumentType.getString(ctx, "mode"));
    }

    private static int setGamemode(CommandContext<CommandSourceStack> ctx, ServerPlayer target, String modeName) {
        if (!OneriaConfig.ENABLE_SILENT_COMMANDS.get()) {
            ctx.getSource().sendFailure(Component.literal("§cSilent commands are disabled."));
            return 0;
        }

        GameType type = parseGameMode(modeName);
        if (type == null) {
            ctx.getSource().sendFailure(Component.literal("§cInvalid gamemode."));
            return 0;
        }

        target.setGameMode(type);

        String sourceName = ctx.getSource().getPlayer() != null ? ctx.getSource().getPlayer().getName().getString() : "Console";
        logToStaff(ctx.getSource(), sourceName + " set " + target.getName().getString() + " to " + modeName);

        if (OneriaConfig.NOTIFY_TARGET.get() && target != ctx.getSource().getEntity()) {
            target.sendSystemMessage(Component.literal("§7[Staff] Your gamemode has been changed to " + modeName));
        }
        return 1;
    }

    private static int silentTeleport(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        if (!OneriaConfig.ENABLE_SILENT_COMMANDS.get()) {
            ctx.getSource().sendFailure(Component.literal("§cSilent commands are disabled."));
            return 0;
        }

        ServerPlayer executor = ctx.getSource().getPlayerOrException();
        ServerPlayer target = EntityArgument.getPlayer(ctx, "target");

        executor.teleportTo(target.serverLevel(), target.getX(), target.getY(), target.getZ(), target.getYRot(), target.getXRot());
        logToStaff(ctx.getSource(), executor.getName().getString() + " TP'd to " + target.getName().getString());
        return 1;
    }

    private static int silentEffect(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        if (!OneriaConfig.ENABLE_SILENT_COMMANDS.get()) {
            ctx.getSource().sendFailure(Component.literal("§cSilent commands are disabled."));
            return 0;
        }

        ServerPlayer target = EntityArgument.getPlayer(ctx, "target");
        ResourceLocation effectId = ResourceLocationArgument.getId(ctx, "effect");
        int duration = IntegerArgumentType.getInteger(ctx, "duration");
        int amplifier = IntegerArgumentType.getInteger(ctx, "amplifier");

        Optional<Holder.Reference<MobEffect>> effect = BuiltInRegistries.MOB_EFFECT.getHolder(ResourceKey.create(BuiltInRegistries.MOB_EFFECT.key(), effectId));

        if (effect.isPresent()) {
            target.addEffect(new MobEffectInstance(effect.get(), duration * 20, amplifier, false, false));
            String sourceName = ctx.getSource().getPlayer() != null ? ctx.getSource().getPlayer().getName().getString() : "Console";
            logToStaff(ctx.getSource(), sourceName + " gave effect " + effectId + " to " + target.getName().getString());

            if (OneriaConfig.NOTIFY_TARGET.get()) {
                target.sendSystemMessage(Component.literal("§7[Staff] An effect has been applied to you."));
            }
        } else {
            ctx.getSource().sendFailure(Component.literal("§cInvalid effect."));
            return 0;
        }
        return 1;
    }

    // --- PLATFORMS HANDLERS ---

    private static int platformSelf(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        return teleportToPlatform(ctx.getSource(), ctx.getSource().getPlayerOrException(), null, "platform1");
    }

    private static int platformTarget(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        return teleportToPlatform(ctx.getSource(), ctx.getSource().getPlayerOrException(), EntityArgument.getPlayer(ctx, "target"), "platform1");
    }

    private static int platformTargetSpecific(CommandContext<CommandSourceStack> ctx) throws CommandSyntaxException {
        return teleportToPlatform(ctx.getSource(), ctx.getSource().getPlayerOrException(), EntityArgument.getPlayer(ctx, "target"), StringArgumentType.getString(ctx, "platform_id"));
    }

    private static int teleportToPlatform(CommandSourceStack source, ServerPlayer executor, ServerPlayer target, String platformId) {
        if (!OneriaConfig.ENABLE_PLATFORMS.get()) {
            source.sendFailure(Component.literal("§cPlatforms system is disabled."));
            return 0;
        }

        for (String pData : OneriaConfig.PLATFORMS.get()) {
            String[] parts = pData.split(";");
            if (parts.length >= 6 && parts[0].equals(platformId)) {
                ResourceKey<Level> dim = ResourceKey.create(net.minecraft.core.registries.Registries.DIMENSION, ResourceLocation.parse(parts[2]));
                ServerLevel level = source.getServer().getLevel(dim);
                if (level == null) {
                    source.sendFailure(Component.literal("§cDimension not found: " + parts[2]));
                    continue;
                }

                Vec3 pos = new Vec3(Double.parseDouble(parts[3]), Double.parseDouble(parts[4]), Double.parseDouble(parts[5]));

                if (target != null) {
                    target.teleportTo(level, pos.x, pos.y, pos.z, 0, 0);
                    target.sendSystemMessage(Component.literal("§e[Staff] You have been teleported to: " + parts[1]));
                    logToStaff(source, executor.getName().getString() + " TP'd " + target.getName().getString() + " to " + parts[1]);
                } else {
                    executor.teleportTo(level, pos.x, pos.y, pos.z, 0, 0);
                    executor.sendSystemMessage(Component.literal("§aTeleported to: " + parts[1]));
                }
                return 1;
            }
        }
        source.sendFailure(Component.literal("§cPlatform not found: " + platformId));
        return 0;
    }

    private static int setPlatform(CommandContext<CommandSourceStack> ctx) {
        final String platformName = StringArgumentType.getString(ctx, "platform_name");
        final ResourceLocation dimension = ResourceLocationArgument.getId(ctx, "dimension");
        final int x = IntegerArgumentType.getInteger(ctx, "x");
        final int y = IntegerArgumentType.getInteger(ctx, "y");
        final int z = IntegerArgumentType.getInteger(ctx, "z");

        String platformEntry = platformName + ";" + platformName + ";" + dimension + ";" + x + ";" + y + ";" + z;

        List<String> platforms = new ArrayList<>(OneriaConfig.PLATFORMS.get());

        boolean updated = false;
        for (int i = 0; i < platforms.size(); i++) {
            if (platforms.get(i).startsWith(platformName + ";")) {
                platforms.set(i, platformEntry);
                updated = true;
                break;
            }
        }

        if (!updated) {
            platforms.add(platformEntry);
        }

        OneriaConfig.PLATFORMS.set(platforms);
        OneriaConfig.SPEC.save();

        final boolean wasUpdated = updated; // Pour la lambda
        ctx.getSource().sendSuccess(() ->
                        Component.literal("§a[Oneria] Platform '" + platformName + "' " +
                                (wasUpdated ? "updated" : "created") + " at " + dimension + " " + x + " " + y + " " + z),
                true
        );

        return 1;
    }

    // --- SCHEDULE HANDLER ---

    private static int showSchedule(CommandContext<CommandSourceStack> ctx) {
        boolean isOpen = OneriaScheduleManager.isServerOpen();
        String timeInfo = OneriaScheduleManager.getTimeUntilNextEvent();
        ctx.getSource().sendSuccess(() -> Component.literal(
                "§8§m----------------------------------\n" +
                        " §6§lSERVER SCHEDULE\n" +
                        " §7Current Status: " + (isOpen ? "§a§lOPEN" : "§c§lCLOSED") + "\n" +
                        " §7Opening: §e" + OneriaConfig.OPENING_TIME.get() + "\n" +
                        " §7Closing: §e" + OneriaConfig.CLOSING_TIME.get() + "\n\n" +
                        " §f" + timeInfo + "\n" +
                        "§8§m----------------------------------"
        ), false);
        return 1;
    }

    // --- UTILS ---

    private static void logToStaff(CommandSourceStack source, String msg) {
        if (!OneriaConfig.LOG_TO_STAFF.get()) return;
        Component txt = Component.literal("§7§o[StaffLog] " + msg);
        source.getServer().getPlayerList().getPlayers().forEach(p -> {
            if (OneriaPermissions.isStaff(p)) p.sendSystemMessage(txt);
        });
        if (OneriaConfig.LOG_TO_CONSOLE.get()) OneriaServerUtilities.LOGGER.info("[StaffLog] " + msg);
    }

    private static GameType parseGameMode(String mode) {
        return switch (mode.toLowerCase()) {
            case "survival", "s", "0" -> GameType.SURVIVAL;
            case "creative", "c", "1" -> GameType.CREATIVE;
            case "adventure", "a", "2" -> GameType.ADVENTURE;
            case "spectator", "sp", "3" -> GameType.SPECTATOR;
            default -> null;
        };
    }

    // --- NICKNAME HANDLERS ---

    private static int setNickname(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer target = EntityArgument.getPlayer(context, "player");
            String nickname = StringArgumentType.getString(context, "nickname");

            // Support color codes & and §
            String formattedNickname = nickname.replace("&", "§");

            // Store in NicknameManager
            NicknameManager.setNickname(target.getUUID(), formattedNickname);

            // Force TabList update for everyone
            target.getServer().getPlayerList().broadcastAll(
                    new ClientboundPlayerInfoUpdatePacket(
                            EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME),
                            List.of(target)
                    )
            );

            context.getSource().sendSuccess(() ->
                    Component.literal("§a[Oneria] Nickname for §f" + target.getName().getString() +
                            "§a set to: " + formattedNickname), true);

            target.sendSystemMessage(Component.literal("§aYour nickname has been changed to: " + formattedNickname));

            OneriaServerUtilities.LOGGER.info("Nickname set for {}: {}", target.getName().getString(), formattedNickname);

            return 1;
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("§cError while setting nickname."));
            OneriaServerUtilities.LOGGER.error("Error setting nickname", e);
            return 0;
        }
    }

    private static int resetNickname(CommandContext<CommandSourceStack> context) {
        try {
            ServerPlayer target = EntityArgument.getPlayer(context, "player");

            // Remove from NicknameManager
            NicknameManager.removeNickname(target.getUUID());

            // Force TabList update
            target.getServer().getPlayerList().broadcastAll(
                    new ClientboundPlayerInfoUpdatePacket(
                            EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME),
                            List.of(target)
                    )
            );

            context.getSource().sendSuccess(() ->
                    Component.literal("§a[Oneria] Nickname for §f" + target.getName().getString() + "§a reset."), true);

            target.sendSystemMessage(Component.literal("§aYour nickname has been reset."));

            OneriaServerUtilities.LOGGER.info("Nickname reset for {}", target.getName().getString());

            return 1;
        } catch (Exception e) {
            context.getSource().sendFailure(Component.literal("§cError while resetting nickname."));
            OneriaServerUtilities.LOGGER.error("Error resetting nickname", e);
            return 0;
        }
    }

    private static int listNicknames(CommandContext<CommandSourceStack> context) {
        int count = NicknameManager.count();

        if (count == 0) {
            context.getSource().sendSuccess(() ->
                    Component.literal("§e[Oneria] No active nicknames."), false);
            return 1;
        }

        StringBuilder list = new StringBuilder("§6╔═══════════════════════════════════╗\n");
        list.append("§6║ §e§lACTIVE NICKNAMES §6(§e").append(count).append("§6)\n");
        list.append("§6╠═══════════════════════════════════╣\n");

        context.getSource().getServer().getPlayerList().getPlayers().forEach(player -> {
            if (NicknameManager.hasNickname(player.getUUID())) {
                String nickname = NicknameManager.getNickname(player.getUUID());
                list.append("§6║ §f")
                        .append(player.getName().getString())
                        .append(" §7→ ")
                        .append(nickname)
                        .append("\n");
            }
        });

        list.append("§6╚═══════════════════════════════════╝");

        context.getSource().sendSuccess(() -> Component.literal(list.toString()), false);
        return 1;
    }

    private static int showColors(CommandContext<CommandSourceStack> ctx) {
        ctx.getSource().sendSuccess(() -> OneriaChatFormatter.getColorsHelp(), false);
        return 1;
    }

    public static Component getColorsHelp() {
        StringBuilder help = new StringBuilder();
        help.append("§6╔═══════════════════════════════╗\n");
        help.append("§6║  §e§lAVAILABLE COLORS§r          §6║\n");
        help.append("§6╠═══════════════════════════════╣\n");

        String[][] colors = {
                {"§0", "BLACK", "&0 or §0"},
                {"§1", "DARK_BLUE", "&1 or §1"},
                {"§2", "DARK_GREEN", "&2 or §2"},
                {"§3", "DARK_AQUA", "&3 or §3"},
                {"§4", "DARK_RED", "&4 or §4"},
                {"§5", "DARK_PURPLE", "&5 or §5"},
                {"§6", "GOLD", "&6 or §6"},
                {"§7", "GRAY", "&7 or §7"},
                {"§8", "DARK_GRAY", "&8 or §8"},
                {"§9", "BLUE", "&9 or §9"},
                {"§a", "GREEN", "&a or §a"},
                {"§b", "AQUA", "&b or §b"},
                {"§c", "RED", "&c or §c"},
                {"§d", "LIGHT_PURPLE", "&d or §d"},
                {"§e", "YELLOW", "&e or §e"},
                {"§f", "WHITE", "&f or §f"}
        };

        for (String[] color : colors) {
            help.append(String.format("§6║ %s§r %-13s §7%s §6║\n",
                    color[0] + "███",
                    color[1],
                    color[2]
            ));
        }

        help.append("§6║                               §6║\n");
        help.append("§6║ §7Formatting Codes:           §6║\n");
        help.append("§6║ §l§lBold§r §7(&l or §l)          §6║\n");
        help.append("§6║ §o§oItalic§r §7(&o or §o)        §6║\n");
        help.append("§6║ §n§nUnderline§r §7(&n or §n)     §6║\n");
        help.append("§6║ §m§mStrike§r §7(&m or §m)        §6║\n");
        help.append("§6║ §k§kObfuscated§r §7(&k or §k)   §6║\n");
        help.append("§6║ §r§rReset§r §7(&r or §r)         §6║\n");
        help.append("§6║                               §6║\n");
        help.append("§6║ §7Usage: Just type & or §     §6║\n");
        help.append("§6║ §7followed by the code!       §6║\n");
        help.append("§6╚═══════════════════════════════╝");

        return Component.literal(help.toString());
    }
}